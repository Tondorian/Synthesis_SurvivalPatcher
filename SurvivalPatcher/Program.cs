using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Plugins;
using Noggog;

namespace SurvivalPatcher
{
    public class Program
    {
        static Lazy<Settings> Settings = new Lazy<Settings>();
        public static async Task<int> Main(string[] args)
        {

            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings(nickname: "Settings", path: "settings.json", out Settings)
                .SetTypicalOpen(GameRelease.SkyrimSE, "SurvivalPatcher.esp")
                .Run(args);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            bool survivalModeFound = false;
            var loadOrder = state.LoadOrder.Keys;
            ModKey survivalModePlugin = state.PatchMod.ModKey;
            foreach (var item in loadOrder)
            {
                if (item.Name == "ccQDRSSE001-SurvivalMode")
                {
                    survivalModeFound = true;
                    survivalModePlugin = item;
                }
            }


            if (!survivalModeFound || survivalModePlugin == state.PatchMod.ModKey)
            {
                Console.WriteLine("Survival Mode not found in the load order. Exiting.");
                return;
            }

            var survivalMode = state.LoadOrder.Where(x => x.ModKey == survivalModePlugin).First().Value.Mod;
            var effects = survivalMode?.MagicEffects.Where(x =>
            {
                if (x.EditorID == null) return false;
                return x.EditorID.Contains("Survival_FoodRestore");
            });
            FormKey verySmall = new FormKey();
            FormKey small = new FormKey();
            FormKey medium = new FormKey();
            FormKey large = new FormKey();
            FormKey vampire = new FormKey();
            FormKey cold = new FormKey();


            List<FormKey> effectFormKeys = new List<FormKey>();

            if (effects != null)
            {
                foreach (var effect in effects)
                {
                    if (effect.EditorID == null) continue;
                    if (effect.EditorID.Contains("VerySmall"))
                    {
                        verySmall = effect.FormKey;
                        effectFormKeys.Add(effect.FormKey);
                        Console.WriteLine($"Found {effect.EditorID}, {effect.FormKey}");
                    }
                    else if (effect.EditorID.Contains("Small"))
                    {
                        small = effect.FormKey;
                        effectFormKeys.Add(effect.FormKey);
                        Console.WriteLine($"Found {effect.EditorID}, {effect.FormKey}");
                    }
                    else if (effect.EditorID.Contains("Medium"))
                    {
                        medium = effect.FormKey;
                        effectFormKeys.Add(effect.FormKey);
                        Console.WriteLine($"Found {effect.EditorID}, {effect.FormKey}");
                    }
                    else if (effect.EditorID.Contains("Large"))
                    {
                        if (effect.EditorID.Contains("Vampire"))
                        {
                            vampire = effect.FormKey;
                            effectFormKeys.Add(effect.FormKey);
                        }
                        else
                        {
                            large = effect.FormKey;
                            effectFormKeys.Add(effect.FormKey);
                        }
                        Console.WriteLine($"Found {effect.EditorID}, {effect.FormKey}");
                    }
                    else if (effect.EditorID.Contains("Cold"))
                    {
                        cold = effect.FormKey;
                        Console.WriteLine($"Found {effect.EditorID}, {effect.FormKey}");
                    }
                }
            }
            var pluginExcludeList = Settings.Value.PluginExcludeList
                .Split(';', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
                .ToHashSet(StringComparer.OrdinalIgnoreCase);
            List<FormKey> alreadyProcessed = new();
            foreach (var modGetter in state.LoadOrder.PriorityOrder)
            {
                List<ISkyrimModGetter?> masters = new();
                var mod = modGetter.Mod;
                if (mod != null)
                {
                    var shouldProcess = Settings.Value.PluginFilter switch
                    {
                        PluginFilter.AllPlugins => true,
                        PluginFilter.ExcludePlugins => !pluginExcludeList.Contains(modGetter.ModKey.FileName.String),
                        _ => true
                    };

                    if (!shouldProcess && modGetter == null)
                        continue;

                    List<FormKey> modFormIds = mod.Ingestibles.Select(x => x.FormKey).ToList();
                    List<IIngestibleGetter> winningOverrides = state.LoadOrder.PriorityOrder.WinningOverrides<IIngestibleGetter>().Where(x => modFormIds.Contains(x.FormKey)).ToList();
                    mod.MasterReferences.Reverse().ForEach(x => masters.Add(state.LoadOrder.GetModByFileName(x.Master.ToString())));
                    foreach (var ingestible in mod.Ingestibles)
                    {
                        if (alreadyProcessed.Contains(ingestible.FormKey) || !ingestible.Flags.HasFlag(Ingestible.Flag.FoodItem) || ingestible.EditorID == null || ingestible.EditorID.StartsWith("SSEssenceOf")) continue;

                        alreadyProcessed.Add(ingestible.FormKey);
                        IIngestibleGetter winningOverrideRecord = winningOverrides.Where(x => x.FormKey == ingestible.FormKey).First();
                        bool survivalDataPresent = false;
                        foreach (var effect in ingestible.Effects)
                        {
                            if (effectFormKeys.Contains(effect.BaseEffect.FormKey))
                            {
                                survivalDataPresent = true;
                                Console.WriteLine($"Survival Data are already present in {ingestible.Name} - skipping");
                            }
                        }

                        if (!survivalDataPresent && winningOverrideRecord.EditorID != null)
                        {
                            Ingestible patchIngestible = state.PatchMod.Ingestibles.GetOrAddAsOverride(winningOverrideRecord);
                            var survivalVersion = survivalMode?.Ingestibles.Where(x => x.FormKey == ingestible.FormKey).FirstOrDefault();
                            if(survivalVersion != null)
                            {
                                var effectsToAdd = survivalVersion.Effects.Where(x => effectFormKeys.Contains(x.BaseEffect.FormKey)).Select(x => x.DeepCopy());
                                patchIngestible.Effects.AddRange(effectsToAdd);
                                Console.WriteLine($"Readded existing SurvivalData to {patchIngestible.Name}");
                                continue;
                            }

                            // aaaBauFood is always verysmall 
                            // Special CACO Ingredients threating:
                            if(winningOverrideRecord.EditorID.StartsWith("CACO_FoodIngr") || winningOverrideRecord.EditorID.StartsWith("aaaBauFood"))
                            {
                                Effect newEffect = new Effect();

                                newEffect.BaseEffect.FormKey = verySmall;
                                newEffect.Data = new EffectData();

                                newEffect.Data.Area = 0;
                                newEffect.Data.Duration = 0;
                                newEffect.Data.Magnitude = 0;

                                patchIngestible.Effects.Add(newEffect);
                                continue;
                            }

                            // Rotten Food is bad
                            if(winningOverrideRecord.EditorID.ToLower().Contains("rotten"))
                            {
                                if(patchIngestible.Keywords == null)
                                    patchIngestible.Keywords = new ExtendedList<IFormLinkGetter<IKeywordGetter>>();
                                patchIngestible.Keywords.Add(new FormKey(survivalMode != null? survivalMode.ModKey: throw new ArgumentException(), 0xFE00083F));
                                Console.WriteLine($"added poison effect to {patchIngestible.Name}");
                            }

                            // Add effects based on weight
                            var effectFormKey = new FormKey();
                            switch (winningOverrideRecord.Weight)
                            {
                                case < 0.4f:
                                    effectFormKey = verySmall;
                                    break;
                                case < 0.6f:
                                    effectFormKey = small;
                                    break;
                                case < 1.1f:
                                    if (winningOverrideRecord.EditorID.ToLower().Contains("cooked"))
                                    {
                                        effectFormKey = large;
                                    }
                                    else
                                    {
                                        effectFormKey = medium;
                                    }
                                    break;
                                case > 1.2f:
                                    effectFormKey = large;
                                    break;
                                default:
                                    effectFormKey = verySmall;
                                    break;
                            }
                            
                            Effect newEffect2 = new Effect();
                            newEffect2.Data = new EffectData();

                            newEffect2.Data.Area = 0;
                            newEffect2.Data.Duration = 0;
                            newEffect2.Data.Magnitude = 0;
                            newEffect2.BaseEffect.FormKey = effectFormKey;
                            patchIngestible.Effects.Add(newEffect2);
                            Console.WriteLine($"added new hunger effect to  {patchIngestible.Name} - Remember this is only weight and name based so it might be unbalanced");


                        }
                    }
                }
            }
            var masterRef = new Mutagen.Bethesda.Plugins.Records.MasterReference();
            masterRef.Master = survivalModePlugin;
            state.PatchMod.ModHeader.MasterReferences.Add(masterRef);
        }

    }
}
